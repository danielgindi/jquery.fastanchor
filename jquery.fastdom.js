// ==ClosureCompiler==
// @compilation_level ADVANCED_OPTIMIZATIONS
// @externs_url https://raw.githubusercontent.com/google/closure-compiler/master/contrib/externs/jquery-1.9.js
// ==/ClosureCompiler==
/** @preserve jquery.fastdom
 * git://github.com/danielgindi/jquery.fastdom.git
 */
(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        define('jquery.fastdom', ['jquery'], factory);
    } else if (typeof exports === 'object') {
        module.exports = factory(require('jquery'));
    } else {
        /*root.fastdom = */factory(root.jQuery);
    }
}(this, function ($) {
    'use strict';

    function touchById(touches, touchId) {
        for (var i = 0; i < touches.length; i++) {
            if (touches[i].identifier === touchId) return touches[i];
        }
        return null;
    }

	var acceptTagNames = {
		'A': true,
		//'INPUT': true, // Does not seem to work for TEXT boxes
		'LABEL': true,
		'BUTTON': true
		//'SELECT': true // Does not seem to really work
	};

    $(window).on('touchstart.fastdom', function (event) {

        var interactive = event.originalEvent.changedTouches[0].target;
        while (interactive && !((interactive.tagName in acceptTagNames) || (interactive.tagName === 'input' && /^radio|checkbox$/g.test(interactive.type)))) {
            interactive = interactive.parentNode;
        }
        if (!interactive || /\bfastdom-ignore\b/.test(interactive.className) || (interactive.tagName === 'LABEL' && !this.click)) return; // Skip this element

        var touchId = event.originalEvent.changedTouches[0].identifier,
            didScroll = false,
            scrollHandler = function () {
                didScroll = true;
            },
            active = true,
            ghostBuster = 0; // Some Android browsers to not support preventDefault(), we need to do catch the ghost events

        var onCancel = function (event) {
            $this
                .removeClass('active') // Remove active class
                .off('touchmove.fastdom') // Unhook touchmove
                .off('touchend.fastdom') // Unhook touchend
                .off('touchcancel.fastdom') // Unhook touchcancel
                .off('click.fastdom'); // Unhook click

            if (event.type === 'touchcancel') {
                $this.off('mousedown.fakebutton');
            }

            trackedScrolling.off('scroll.fastdom', scrollHandler) // Stop tracking scroll
        };

        var $this = $(interactive);

        var trackedScrolling = $this.parents().add(window);
        trackedScrolling.on('scroll.fastdom', scrollHandler); // Start tracking scroll to prevent "click" after scroll

        $this
            .addClass('active') // Add active class
            .on('touchmove.fastdom', function (event) { // Start tracking touch movement to see if we are still on top

                var touch = touchById(event.originalEvent.changedTouches, touchId);
                if (!touch) return;

                var element = document.elementFromPoint(touch.pageX, touch.pageY);
                active = element && (this === element || $.contains(this, element));
                $this.toggleClass('active', !!active);

            }).on('touchend.fastdom', function (event) {

                var that = this;
		
                var touch = touchById(event.originalEvent.changedTouches, touchId);
                if (!touch) return;

                onCancel(event);

                if (active && !didScroll && !event.isDefaultPrevented() && document.contains(this)) {
                	var didClick = false;
                    event.preventDefault();

                    // Defer the click event, so we can detect fake clicks generated by some browsers
                    var clickTimeout = setTimeout(function () {
                    	didClick = true;
                        if (that.click) {
                            that.click(); // Trigger native event
                        } else { // Android Chrome and Android Browser are special!
                            var clickEvent = document.createEvent('MouseEvent');
                            clickEvent.initEvent('click', true, true);
                            that.dispatchEvent(clickEvent);
                        }
                    }, 0);

                    // Listen to a click event.
                    // It may be our own fake click event, so the "one" will be consumed,
                    // Or it may be a fake click event generated by some browsers.
                    $this.one('click.fastdom', function (event) {
                        didClick = true;
                        
                        // Prevent our fake click if we already got one.
                        if (clickTimeout) {
                        	clearTimeout(clickTimeout);
                        	clickTimeout = null;
                        }
                    });
                }

            }).on('touchcancel.fastdom', onCancel)
            .on('mousedown.fastdom', function (event) {
                if ((+new Date - ghostBuster) <= 500) { // Bust the ghost mouse events on old Android browsers
                    event.preventDefault();
                    event.stopPropagation();
                }
                $this.off('mousedown.fastdom');
            })

    });

}));
